naiveImputation = function(x){
  require(zoo)
  nobserved = length(na.omit(x))
  n = length(x)
  type = ifelse(nobserved == 0, "none",
    ifelse(nobserved == 1, "repeat", "naive"))
  switch(type,
         "none" = {tmp = rep(NA, n)},
         "repeat" = {tmp = rep(na.omit(x), n)},
         "naive" = {tmp = na.locf(na.locf(na.approx(x, na.rm = FALSE),
            na.rm = FALSE), na.rm = FALSE, fromLast = TRUE)}
         )
  as.numeric(tmp)
}

ensembleImpute = function(x, plot = FALSE){
    missIndex = which(is.na(x))
    T = length(x)
    time = 1:T
    n.miss = length(missIndex)
    n.obs = T - n.miss
    if(n.miss > 0){
        if(n.obs >= 5 & var(x, na.rm = TRUE) != 0){
            ## Start fitting
            meanFit = rep(mean(x, na.rm = TRUE), T)
            meanFitError = 1/sum(abs(x - meanFit), na.rm = TRUE)

            lmFit = predict(lm(formula = x ~ time),
                newdata = data.frame(time = time))
            lmFit[lmFit < 0] = 0
            lmFitError = 1/sum(abs(x - lmFit), na.rm = TRUE)

            expFit = exp(predict(lm(formula = log(x + 1) ~ time),
                newdata = data.frame(time = time)))
            expFitError = ifelse(n.obs/T >= 0.75 &
                length(na.omit(tail(x, 5))) > 0,
                1/sum(abs(x - expFit), na.rm = TRUE), 0)

            ## lm2Fit = predict(lm(formula = x ~ poly(time, 2)),
            ##     newdata = data.frame(time = time))
            ## lm2Fit[lm2Fit < 0] = 0
            ## lm2FitError = 1/sum(abs(x - lm2Fit), na.rm = TRUE)

            loessFit = try(predict(loess(formula = x ~ time,
                control = loess.control(surface = "direct"), span = 0.6,
                degree = 1), newdata = data.frame(time)))
            if(!inherits(loessFit, "try-error") &
               sum(abs(x - loessFit), na.rm = TRUE) > 0.1 &
               n.obs/T >= 0.5){
                loessFit[loessFit < 0] = 0
                loessFitError = 1/sum(abs(x - loessFit), na.rm = TRUE)
            } else {
                loessFit = rep(0, T)
                loessFitError = 0
            }

            xmax = max(x, na.rm = TRUE)
            x.scaled = x/xmax
            logisticFit = predict(glm(formula = x.scaled ~ time,
                family = "binomial"), newdata = data.frame(time = time),
                type = "response") *
                    xmax
            logisticFitError = 1/sum(abs(x - logisticFit), na.rm = TRUE)

            ## tmp = na.approx(x, na.rm = FALSE)
            ## arimaFit = tmp
            ## ## print(obs)
            ## ## print(c(NA, fitted(auto.arima(tmp))[-1]))
            ## fit = auto.arima(tmp, seasonal = FALSE)
            ## arimaFit = c(fitted(fit)[-1], NA)
            ## ## check <<- arimaFit
            ## if(var(arimaFit, na.rm = TRUE) > 1e-3){
            ##     obs = which(!is.na(arimaFit))
            ##     numberForward =
            ##         length(which(is.na(arimaFit[max(obs):length(arimaFit)])))
            ##     if(numberForward > 0)
            ##         arimaFit[(max(obs) + 1):length(arimaFit)] =
            ##             c(forecast(fit, h = numberForward)$mean)
            ##     numberBackward =
            ##         length(which(is.na(arimaFit[min(obs):1])))
            ##     if(numberBackward > 0)
            ##         arimaFit[(min(obs) - 1):1] =
            ##             c(forecast(auto.arima(rev(arimaFit),
            ##                                   seasonal = FALSE),
            ##                        h = numberBackward)$mean)
            ##     arimaFit[arimaFit < 0]  = 0
            ##     ## arimaFitError = 1/sum(abs(x - arimaFit), na.rm = TRUE)
            ##     arimaFitError =
            ##         mean(c(meanFitError, lmFitError,
            ##                expFitError[expFitError != 0],
            ##                loessFitError[loessFitError != 0],
            ##                logisticFitError), na.rm = TRUE)
            ## } else {
            ##     arimaFit = rep(0, T)
            ##     arimaFitError = 0
            ## }


            naiveFit = naiveImputation(x)
            naiveFitError = mean(c(meanFitError, lmFitError,
                           expFitError[expFitError != 0],
                           loessFitError[loessFitError != 0],
                           logisticFitError), na.rm = TRUE)

            ## Construct the ensemble
            weights =
                c(mean = meanFitError,
                  lm = lmFitError,
                  exp = expFitError,
                  loess = loessFitError,
                  logistic = logisticFitError,
                  ## arima = arimaFitError,
                  naive = naiveFitError)^2/
                    sum(c(meanFitError,
                          lmFitError,
                          exp = expFitError,
                          loess = loessFitError,
                          logisticFitError,
                          ## arima = arimaFitError,
                          naiveFitError)^2, na.rm = TRUE)
            weights[is.na(weights)] = 0
            ## print(weights)
            finalFit = (meanFit * weights["mean"] +
                        lmFit * weights["lm"] +
                        expFit * weights["exp"] +
                        loessFit * weights["loess"] +
                        logisticFit * weights["logistic"] +
                        ## arimaFit * weights["arima"] +
                        naiveFit * weights["naive"])

            if(plot){
                plot(x ~ time,
                     ylim = c(0,
                         max(c(x,
                               lmFit,
                               logisticFit,
                               ## arimaFit,
                               loessFit
                               ),
                         na.rm = TRUE)),
                     pch = 19)
                lines(meanFit, col = "red")
                lines(lmFit, col = "orange")
                lines(expFit, col = "gold")
                lines(loessFit, col = "brown")
                lines(logisticFit, col = "green")
                ## lines(arimaFit, col = "purple")
                lines(naiveFit, col = "blue")
                lines(finalFit, col = "steelblue", lwd = 3)
                legend("topleft", legend = c("mean", "linear", "exponential",
                                      "loess", "logistic", "arima",
                                      "naive", "final"),
                       col = c("red", "orange", "gold", "brown",
                           "green", "purple", "blue",
                           "steelblue"), lwd = c(rep(1, 7), 3), bty = "n",
                       lty = 1)

            }
            x[missIndex] = finalFit[missIndex]
        } else {
            x = naiveImputation(x)
        }
    }
    round(x, 3)
}





